/**
 * DocFlow Generate Command
 * Generate documentation and CLAUDE.md
 */

import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import fse from 'fs-extra';
import { join } from 'path';
import { glob } from 'glob';
import { loadConfig } from '../utils/config.js';
import { detectProjectType, detectTechStack, detectFrameworks } from '../utils/detect.js';
import { generateERD, saveERD } from '../../generators/erd.js';
import { generateDependencyGraph, saveDependencyGraph } from '../../generators/dependency-graph.js';
import { generateAllWorkflowDiagrams, saveWorkflowDiagrams } from '../../generators/workflow-diagram.js';

export const generateCommand = new Command('generate')
  .description('Generate documentation')
  .argument('[type]', 'What to generate (claude, readme, diagrams, all)', 'all')
  .option('-o, --output <path>', 'Output path')
  .option('-f, --force', 'Overwrite existing files')
  .option('--format <format>', 'Output format (markdown, separate)', 'markdown')
  .option('--diagram-type <type>', 'Diagram type (erd, dependencies, workflows, all)', 'all')
  .option('--entry <files...>', 'Entry points for dependency graph')
  .option('--max-depth <depth>', 'Maximum depth for dependency graph', '5')
  .action(async (type, options) => {
    console.log(chalk.cyan(`\n  DocFlow Generate: ${type}\n`));

    const cwd = process.cwd();
    const spinner = ora('Loading configuration...').start();

    try {
      const config = await loadConfig(cwd);

      if (!config && type !== 'claude' && type !== 'diagrams') {
        spinner.fail('No docflow.config.json found. Run `docflow init` first.');
        process.exit(1);
      }

      spinner.succeed('Configuration loaded');

      if (type === 'claude' || type === 'all') {
        spinner.start('Generating CLAUDE.md...');
        await generateClaudeMd(cwd, config, options);
        spinner.succeed('Generated CLAUDE.md');
      }

      if (type === 'readme' || type === 'all') {
        spinner.start('Updating README.md...');
        // README generation would go here
        spinner.succeed('README.md is up to date');
      }

      if (type === 'diagrams' || type === 'all') {
        await generateDiagrams(cwd, options, spinner);
      }

      console.log(chalk.green('\n  Generation complete!\n'));

    } catch (error) {
      spinner.fail(`Error: ${error.message}`);
      process.exit(1);
    }
  });

async function generateClaudeMd(cwd, config, options) {
  const outputPath = options.output || join(cwd, 'CLAUDE.md');

  // Check if exists and not forcing
  if (await fse.pathExists(outputPath) && !options.force) {
    // Merge with existing
    const existing = await fse.readFile(outputPath, 'utf-8');
    if (existing.includes('## Auto-Generated Section')) {
      // Update only auto-generated section
      const parts = existing.split('## Auto-Generated Section');
      const autoSection = await buildAutoSection(cwd, config);
      await fse.writeFile(outputPath, parts[0] + '## Auto-Generated Section\n\n' + autoSection);
      return;
    }
  }

  // Generate full CLAUDE.md
  const content = await buildClaudeMd(cwd, config);
  await fse.writeFile(outputPath, content);
}

async function buildClaudeMd(cwd, config) {
  const projectType = await detectProjectType(cwd);
  const techStack = await detectTechStack(cwd);
  const frameworks = await detectFrameworks(cwd);
  const folderStructure = await getFolderStructure(cwd);
  const commonCommands = getCommonCommands(projectType, techStack);

  const sections = [];

  // Header
  sections.push(`# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with this codebase.
`);

  // Project Overview
  sections.push(`## Project Overview

**Name**: ${config?.project?.name || 'Unknown'}
**Description**: ${config?.project?.description || 'No description'}
**Type**: ${projectType}
**Language**: ${config?.project?.language || 'English'}
`);

  // Tech Stack
  if (techStack.length) {
    sections.push(`## Tech Stack

${techStack.map(t => `- ${t}`).join('\n')}
`);
  }

  // Frameworks
  if (frameworks.length) {
    sections.push(`## Frameworks & Libraries

${frameworks.map(f => `- ${f}`).join('\n')}
`);
  }

  // Folder Structure
  sections.push(`## Folder Structure

\`\`\`
${folderStructure}
\`\`\`
`);

  // Common Commands
  sections.push(`## Common Commands

\`\`\`bash
${commonCommands.map(c => `# ${c.description}\n${c.command}`).join('\n\n')}
\`\`\`
`);

  // Auto-generated section marker
  sections.push(`## Auto-Generated Section

> This section is auto-generated by DocFlow. Manual edits below this line may be overwritten.

*Last generated: ${new Date().toISOString().split('T')[0]}*
`);

  return sections.join('\n');
}

async function buildAutoSection(cwd, config) {
  const lines = [];

  // Add dynamic content
  lines.push(`*Last updated: ${new Date().toISOString().split('T')[0]}*`);
  lines.push('');

  // Could add more auto-generated content here
  // - API endpoints discovered
  // - Test coverage
  // - Recent changes

  return lines.join('\n');
}

async function getFolderStructure(cwd, depth = 3) {
  const ignore = ['node_modules', '.git', 'dist', 'build', 'coverage', '__pycache__', '.next', 'vendor'];

  const lines = [];
  const rootName = cwd.split(/[/\\]/).pop();
  lines.push(rootName + '/');

  async function walk(dir, prefix = '', currentDepth = 0) {
    if (currentDepth >= depth) return;

    const entries = await fse.readdir(dir, { withFileTypes: true });
    const filtered = entries
      .filter(e => !ignore.includes(e.name) && !e.name.startsWith('.'))
      .sort((a, b) => {
        if (a.isDirectory() && !b.isDirectory()) return -1;
        if (!a.isDirectory() && b.isDirectory()) return 1;
        return a.name.localeCompare(b.name);
      });

    for (let i = 0; i < filtered.length; i++) {
      const entry = filtered[i];
      const isLast = i === filtered.length - 1;
      const connector = isLast ? '└── ' : '├── ';
      const newPrefix = prefix + (isLast ? '    ' : '│   ');

      if (entry.isDirectory()) {
        lines.push(`${prefix}${connector}${entry.name}/`);
        await walk(join(dir, entry.name), newPrefix, currentDepth + 1);
      } else {
        lines.push(`${prefix}${connector}${entry.name}`);
      }
    }
  }

  await walk(cwd);
  return lines.join('\n');
}

function getCommonCommands(projectType, techStack) {
  const commands = [];

  if (techStack.includes('npm') || projectType === 'node') {
    commands.push(
      { command: 'npm install', description: 'Install dependencies' },
      { command: 'npm run dev', description: 'Start development server' },
      { command: 'npm test', description: 'Run tests' },
      { command: 'npm run build', description: 'Build for production' },
    );
  }

  if (techStack.includes('pip') || projectType === 'python') {
    commands.push(
      { command: 'pip install -r requirements.txt', description: 'Install dependencies' },
      { command: 'python -m pytest', description: 'Run tests' },
    );
  }

  if (projectType === 'powershell') {
    commands.push(
      { command: 'Invoke-Pester', description: 'Run Pester tests' },
      { command: 'Invoke-ScriptAnalyzer -Path .', description: 'Lint PowerShell scripts' },
    );
  }

  if (projectType === 'dotnet') {
    commands.push(
      { command: 'dotnet restore', description: 'Restore dependencies' },
      { command: 'dotnet build', description: 'Build solution' },
      { command: 'dotnet test', description: 'Run tests' },
    );
  }

  // Git commands (always useful)
  commands.push(
    { command: 'git status', description: 'Check git status' },
    { command: 'git pull', description: 'Pull latest changes' },
  );

  return commands;
}

async function generateDiagrams(cwd, options, spinner) {
  const diagramType = options.diagramType || 'all';
  const format = options.format || 'markdown';
  const docsDir = join(cwd, 'docs', 'diagrams');

  await fse.ensureDir(docsDir);

  // Generate ERD
  if (diagramType === 'erd' || diagramType === 'all') {
    try {
      spinner.start('Generating Entity Relationship Diagram...');
      const result = await generateERD(cwd, {
        format,
        output: options.output || join(docsDir, 'erd.md')
      });

      const outputPath = options.output || join(docsDir, 'erd.md');
      await saveERD(result, outputPath, format);

      spinner.succeed(`Generated ERD (${result.diagrams.length} diagram(s))`);
    } catch (error) {
      spinner.warn(`ERD generation skipped: ${error.message}`);
    }
  }

  // Generate Dependency Graph
  if (diagramType === 'dependencies' || diagramType === 'all') {
    try {
      spinner.start('Generating Dependency Graph...');
      const result = await generateDependencyGraph(cwd, {
        entryPoints: options.entry,
        maxDepth: parseInt(options.maxDepth, 10),
        format,
        output: options.output || join(docsDir, 'dependencies.md')
      });

      const outputPath = options.output || join(docsDir, 'dependencies.md');
      await saveDependencyGraph(result, outputPath, format);

      spinner.succeed(`Generated Dependency Graph (${result.graph.nodes.size} modules)`);
    } catch (error) {
      spinner.warn(`Dependency graph generation skipped: ${error.message}`);
    }
  }

  // Generate Workflow Diagrams
  if (diagramType === 'workflows' || diagramType === 'all') {
    try {
      spinner.start('Generating Workflow Diagrams...');
      const result = await generateAllWorkflowDiagrams(cwd, {
        format,
        output: options.output || join(docsDir, 'workflows.md')
      });

      const outputPath = options.output || join(docsDir, 'workflows.md');
      await saveWorkflowDiagrams(result, outputPath, format);

      spinner.succeed(`Generated Workflow Diagrams (${result.diagrams.length} workflow(s))`);
    } catch (error) {
      spinner.warn(`Workflow diagram generation skipped: ${error.message}`);
    }
  }
}
